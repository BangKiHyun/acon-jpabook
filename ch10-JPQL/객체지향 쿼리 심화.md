# 객체지향 쿼리 심화

## 벌크 연산

### 벌크 연산이란

엔티티를 수정하려면 영속성 컨텍스트의 변경 감지 기능이나 병합을 사용하고, 삭제하려면 EntityManager.remove() 메서드를 사용한다.
하지만 수 백개 이상의 엔티티를 하나씩 처리하기에는 시간이 너무 오래 걸린다. 이럴 때 **여러건을 한 번에 수정하거나 삭제하는 벌크 연산**을 사용하면 된다.

~~~
String qlString = 
	"update Product p " +
	"set p.price = p.price * 1.1 " +
	"where p.stockAmount < :stockAmount";
	
int resultCount = em.createQuery(qlString)
	.setParameter("stockAmount", 10)
	.executeUpdate();
~~~

위 코드는 재고가 10개 미만은 모든 상품의 금액을 10% 상승시키는 예제다.
벌크 연산은 **executeUpdate() 메서드**를 사용한다. 이 메서드는 **벌크 연산으로 영향을 받은 엔티티 건수를 반환**한다.

</br >

### 벌크 연산 주의점

벌크 연산은 영속성 컨텍스트를 무시하고 DB에 직접 쿼리한다.
다음은 벌크 연산 시 문제점을 유발하는 코드다.

~~~
//상품 A조회(상품A의 가격은 1000)
Product productA =
	em.createQuery("select p from Product p where p.name = :name",
		Product.class)
		.setParameter("name", ""productA")
		.getSingleResult();
		
	//출력 결과: 1000
	System.out.println("productA 수정 전 = " + productA.getPrice());
	
	//벌크 연산 수행
	em.createQuery("update Product p set p.price = p.price * 1.1")
		.executeUpdate();
		
	//출력 결과: 1000
		System.out.println("productA 수정 후 = " + productA.getPrice());
~~~

처음 조회한 상품A의 가격은 **영속성 컨텍스트에서 관리**된다.
벌크 연산을 수행한 후 모든 상품의 가격은 10% 상승해 1100원이 되어야 하지만 1000원이 출력되었다.
이와 같이 벌크 연산은 **영속성 컨텍스트를 통하지 않고 DB에 직접 쿼리**하기 때문에 주의해서 사용해야한다.

</br >

### 벌크 연산 주의점 해결방안

- em.refresh()
  - 벌크 연산을 수행한 직후 정확한 상품A 엔티티를 사용해야 한다면
    em.refresh(productA)를 통해 DB에서 상품 A를 다시 조회하면 된다.
- 벌크 연산 먼저 실행
  - 가장 실용적인 방법이다.
  - 말 그대로 벌크 연산을 먼저 실행하고 나서 상품 A를 조회하면 벌크 연산으로 이미 변경된 상품 A를 조회한다.
- 벌크 연산 수행 후 영속성 컨텍스트 초기화
  - 벌크 연산을 수행한 후 바로 영속성 컨텍스트를 초기화해서 영속성 컨텍스트에 남아 있는 엔티티를 제거하는 방법이다.
  - 그렇지 않으면 아까 보았듯이 영속성 컨텍스트에 남아있는 엔티티를 조회해 의도치 않은 결과를 나을 수 있다.

</ br>

## 영속성 컨텍스트와 JPQL

### 쿼리 후 영속성 상태인 것과 아닌 것

JPQL의 조회 대상은 엔티티, 임베디드 타입, 값 타입 같이 다양한 종류가 있다.
여기서 **영속성 컨텍스트가 관리하는 대상은 엔티티** 뿐이다.

### JPQL로 조회한 엔티티와 영속성 컨텍스트

JPQL로 데이터베이스에서 조회한 엔티티가 영속성 컨텍스트에 이미 있으면 **JPQL로 데이터베이스에서 조회한 결과를 버리고 영속성 컨텍스트에 있던 엔티티를 반환한다.**

다음과 같이 3가지 경우가 있다고 가정해보자

1. 새로운 엔티티를 영속성 컨텍스트에 하나 더 추가한다.
2. 기존 엔티티를 새로 검색한 엔티티로 대체한다.
3. 기존 엔티티는 그대로 두고 새로 검색한 엔티티를 버린다.

1번의 문제점
영속성 컨텍스트는 **기본 키 값을 기준으로 엔티티를 관리**한다. 따라서 같은 기본 키 값을 가진 엔티티는 등록할 수 없다. 

2번의 문제점
영속성 컨텍스트에 수정 중인 데이터가 사라질 수 있으므로 위험하다.

3번
**영속성 컨텍스트는 영속 상태인 엔티티의 동일성을 보장**한다.
em.find()로 조회하든 JPQL을 사용하든 영속성 컨텍스트가 같으면 동일한 엔티티를 반환한다.

</br >

### find() vs JPQL

em.find() 메서드는 **영속성 컨텍스트에서 엔티티를 먼저 찾고 없으면 데이터베이스를 조회**한다.
반면에, JPQL을 사용하면 **데이터베이스를 먼저 조회**하고 영속성 컨텍스트에 이미 같은 엔티티가 있으면 새로 검색한 엔티티는 버리고 영속성 컨텍스트에 있는 기존 엔티티를 반환한다.

</br >

### JPQL의 특징 정리

- JPQL은 항상 데이터베이스를 조회한다.
- JPQL로 조회한 엔티티는 영속 상태다.
- 영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환한다.

</br >

## JPQL과 플러시 모드

### 플러시 모드란

플러시는 영속성 컨텍스트의 변경 내역을 데이터베이스에 동기화하는 것이다.

em.flush()를 사용하는 방법과 플러시 모드에 따라 커밋하기 직전이나 쿼리 실행 직전에 자동으로 플러시를 호출하는 방법이 있다.

- em.setFlushMode(FlushModeType.AUTO) //커밋 또는 쿼리 실행 시 플러시(default)
- em.setFlushMode(FlushModeType.COMMIT) //커밋시에만 플러시

</br >

### 쿼리와 플러시 모드

JPQL은 영속성 컨텍스트에 있는 데이터를 고려하지 않고 데이터베이스에서 데이터를 조회한다.
따라서 JPQL을 실행하기 전에 영속성 컨테스트의 내용을 데이터베이스에 반영해야 한다.

플러시 모드의 기본값은 AUTO이기 때문에 JPQL 실행전 플러시를 통해 데이터베이스와 동기화 할 수 있다.

### 플러시 모드와 최적화

FlushModeType.COMMIT 모드는 트랜잭션을 커밋할 때만 플러시한다.
따라서 JPA쿼리를 사용할 떄 영속성 컨텍스트에는 있지만 데이터베이스에 반영하지 않은 데이터를 조회할 수 없다.(데이터 무결성에 문제가 발생할 수 있다.)
그럼에도 다음과 같은 상황에서 사용하면 성능을 최적화할 수 있다.

~~~
//비즈니스 로직
등록()
쿼리() //플러시
등록()
쿼리() //플러시
커밋() //플러시
~~~

