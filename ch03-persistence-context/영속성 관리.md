## 영속성 관리

1. ### 엔티티 매니저 팩토리와 엔티티 매니저 

   - 엔티티 매니저 팩토리

     - EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");
     - 엔티티 매니저 팩토리를 만드는 비용은 상당히 크다.
     - 따라서 한 개만 만들어서 애플리케이션 전체에세 공유하도록 설계되어 있다.
     - 여러 스레드가 동시에 접근해도 안전하다. 그러므로 여러 스레드 간에 공유해도 된다.

   - 엔티티 매니저

     - EnitityManager em = emf.createEntityManager();
     - 위 과정은 비용이 거의 안든다.
     - 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안된다.
     - 엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다.
       보통은 트랜잭션을 시작할 때 커넥션을 획득한다.

     

2. ### 영속성 컨텍스트

   - 영속성 컨텍스트는 우리말로 번역하면 **'엔티티를 영구 저장하는 환경'** 이라는 뜻이다.
   - 엔티티 매니저로 엔티티를 저장하거나 조회하면 **엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리**한다.
   - 보통 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다.



3. ### 영속성 생명주기

   엔티티에는 4사지 상태가 있다.

   - 비영속(new/transient) : 영속성 컨텍스트와 **전혀 관계가 없는** 상태
   - 영속(mamaged) : 영속성 컨텍스트에 **저장된** 상태
   - 준영속(detached) : 영속성 컨텍스트에 **저장되었다가 분리**된 상태
   - 삭제(removed) ; 삭제된 상태

   

   1. 비영속
      - 엔티티를 객체를 생성했을 당시를 의미한다.
      - Member member = new Member();
   2. 영속
      - 영속성 컨텍스트에 의해 관리되는 엔티티를 의미한다.
      - em.persist(), em.find()
      - JPQL을 사용해서 조회한 엔티티
   3. 준영속
      - 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않는 상태를 의미한다.
      - 준영속 상태로 만들려면 em.detach() 를 호출하면 된다.
      - em.close() 를 호출해서 영속성 컨텍스트를 닫거나 em.clear() 를 호출해서 영속성 컨텍스트를 초기화해도
        영속성 컨텍스트가 관리하던 영속 상태의 엔티티는 준영속 상태가 된다.
   4. 삭제
      - 엔티티를 영속성 켄텍스트와 데이터 베이스에서 삭제하는것을 의미한다.
      - em.remove();



4. ### 영속성 컨텍스트 특징

   - 식별자 값

     - 영속성 컨텍스트는 엔티티를 식별자 값(@id)로 구분한다.
     - 따라서 영속 상태는 식별자 값이 반드시 있어야 한다. 그렇지 않으면 예외 발생!

   - 데이터베이스 저장

     - 영속성 컨텍스트에 데이터를 저장하면 이 엔티티는 DB에 바로 저장되지 않는다.
     - 보통 트랜잭션을 커밋하는 순간 영속성 컨테스트에 새로 저장된 엔티티를 DB에 반영한다.
       이를 플러시(flush)라 한다.

   - 장점

     - 1차 캐시
     - 동일성 보장
     - 트랜잭션을 지원하는 쓰기 지연
     - 변경 감지
     - 지연 로딩

     

     1. 1차 캐시
        - 영속성 컨택스트 내부에 캐시를 갖고있는데 이것을 1차 캐시라고 한다.
        - 이곳에서 영속 상태의 엔티티는 @Id를 키값으로 갖고, 엔티티 인스턴스를 value로 갖는다
        - 엔티티를 조회할 때 먼저 1차 캐시에서 엔티티를 찾고, 1차 캐시에 없으면 DB에서 조회한다.
          DB에서 조회한 엔티티는 1차 캐시에 저장된 후 영속 상태의 엔티티를 반환한다.
        - 엔티티 조회시 메모리에 있는 1차 캐시에서 바로 불러오기 떄문에 성능상 이점이 있다.
     2. 영속 엔티티 동일성(identity) 보장
        - em.find(Member.class, "member1") 를 반복해서 호출해도 1차 캐시에 있는 같은 엔티티를 반환하기 때문에
          엔티티의 동일성을 보장해 준다.
     3. 엔티티 등록
        - 엔티티 매니저는 **트랜잭션을 커밋하기 직전까지 DB에 엔티티를 저장하지 않고 내부 쿼리 저장소(쓰기 지연 SQL)에 차곡차곡 모아둔다.**
        - 트랜잭션을 커밋할 때 모아둔 쿼리를 DB에 보내는데 이를 **쓰기 지연** 이라 한다.
        - 트랜잭션을 커밋하면 엔티티 매니저는 우선 영속성 컨텍스트를 플러시한다.
          - 플러시 : 쓰기 지연 SQL 저장소에 모인 쿼리를 DB에 보낸다.
     4. 변경 감지(더티 체킹)
        - SQL을 사용하면 수정 쿼리를 직접 작성해야 한다. 프로젝트가 점점 커지고 요구사항이 늘어나면서 수정 쿼리도 점점 추가해야되는 수고가 발생한다.
        - JPA는 수정할 때 단순히 **엔티티를 조회해서 데이터만 변경**하면 된다.
          이렇게 변경된 엔티티는 DB에 자동으로 반영되는데 이러한 기능을 **변경 감지(더티 체킹)**라 한다.
        - 더티 체킹 방법
          - JPA는 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해둔다(스냅샷).
          - 그리고 플러시 시점에 스냅샷과 엔티티를 비교하여 변경된 엔티티에 대한 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.
          - 보내진 쿼리는 DB에 전달한다.
        - 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
     5. 엔티티 삭제
        - em.remove() 에 삭제 대상 엔티티를 넘겨주면 삭제한다.
        - 즉시 삭제하는 것이 아니라 삭제 뭐리를 쓰기 지연 SQL 저장소에 삭제 쿼리를 전달한다.
        - 다만 영속성 컨텍스트에서는 제거되기 때문에, 이렇게 삭제된 엔티티는 재사용하지 말고 자연스럽게 GC가 관리하게 두는 것이 좋다.