## 기본 키 매핑



### @Entity

JPA를 사용해서 테이블과 매핑할 클래스에 붙여주는 어노테이션

속성

- name : JPA에서 사용할 엔티티 이름을 설정한다. 기본값으로는 클래스 이름을 그대로 사용한다.

특징

- 기본 생성자는 필수(파마미터가 없는 생성자)
- final 클래스, enum, interface, inner 클래스에는 사용 불가능
- 저장할 필드에 final을 사용하면 안된다.



### @Talbe

엔티티와 매핑할 테이블을 지정한다.

속성

- name : 매핑할 테이블 이름, 기본값으로 엔티티 이름 사용
- catalog : catalog 기능이 있는 DB에서 catalog를 매핑
- schema : schema 기능이 있는 DB에서 schema를 매핑
- uniqueConstraints : DDL 생성 시에 유니크 제약조건을 만든다.
  이 기능은 스키마 자동 생성 기능을 사용해서 DDL을 만들 때만 사용된다.



### 기본 키 매핑

- 직접 할당 : 기본 키를 애플리케이션에서 직접 할당

- 자동 생성 : 대리 키 사용 방식

  - IDENTITY: 기본 키 생성을 DB에 위임
  - SEQUENCE: DB 시퀀스를 사용해서 기본 키를 할당
  - TABLE: 키 생성 테이블을 사용

  자동 생성 전략이 다양한 이유는 DB 벤더마다 지원하는 방식이 다르기 때문이다.

  오라클 DB는 시퀀스를 제공하지만 MySQL은 시퀀스를 제공하지 않는다.
  대신 MySQL은 AUTO_INCREMENT 기능을 제공한다.

  따라서 SEQUENCE나 IDENTITY 전략은 사용하는 DB에 의존한다.



### IDENTITY 전략

기본 키 생성을 DB에 위임하는 전략으로 주로 MySQL, PostgreSQL 에서 사용한다.
예를 들어 MySQL의 AUTO_INCREMENT 기능은 DB가 기본 키를 자동으로 생성해준다.

IDENTITY 전략은 AUTO_INCREMENT를 사용한 예제처럼 DB에 값을 저장하고 나서 기본 키 값을 구할 수 있을 때 사용한다.

- IDENTITY 전략과 최적화
  - IDENTITY 전략은 데이터를 DB에 INSERT한 후에 기본 키 값을 조회할 수 있다. 따라서 엔티티에 식별자 값을 할당하려면 JPA는 추가로 DB를 조회해야 한다.
  - 주의할 점은 이 전략은 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다.
    이 전략은 엔티티를 DB에 저장해야 식별자를 구할 수 있으므로 em.persist()를 호출하는 즉시 INSERT SQL이 DB에 전달된다.



### SEQUENCE 전략

DB 시퀀스는 유일한 값을 순서대로 생성하는 특별한 DB 오브젝트다.
SEQUENCE 전략은 이 시퀀스를 사용해서 기본 키를 생성한다.

이 전략은 오라클, PostgreSQL, H2 DB에서 사용할 수 있다.

- SEQUENCE 전략 동작 순서
  - 시퀀스 사용 코드는 IDENTITY 전략과 같지만 내부 동작 방식은 다르다.
  - SEQUENCE 전략은 em.persist()를 호출할 때 먼저 DB 시퀀스를 사용해서 식별자를 조회한다.
    그리고 조회한 식별자를 엔티티에 할당한 후에 엔티티를 영속성 컨텍스트에 저장한다.
  - 이후 트랜잭션을 커밋해서 플러시가 일어나면 엔티티를 DB에 저장한다.
  - IDENTITY 전략과 반대되는 순서이다.



### Table 전략

TABLE 전략은 키 생성 전용 테이블을 하나 만들고 여기에 이름과 값으로 사용할 컬럼을 만들어 DB 시퀀스를 흉내내는 전략이다.
테이블을 사용하므로 모든 데이터베이스에 적용할 수 있다.

- TABLE 전략과 최적화
  - TABLE 전략은 값을 조회하면서 SELECT 쿼리를 사용하고 다음 값으로 증가시키기위해 UPDATE 쿼리를 사용한다.
  - 이 전략은 SEQUENCE 전략과 비교해서 DB와 한 번 더 통신하는 단점이 있다.
  - TABLE 전략을 최적화하려면 @TableGenerator.allocationSize를 사용하면 된다.
    이 값을 사용해서 최적화하는 방법은 SEQUENCE 전략과 같다.



### 정리

영속성 컨텍스트는 엔티티를 식별자 값으로 구분하므로 엔티티를 영속 상태로 만들려면 식별자 값이 반드시 있어야 한다.
em.persist() 를 호출한 직후에 발생하는 일을 식별자 할당 전략별로 정리하면 다음과 같다.

- 직접 할당 : em.persist() 를 호출하기 전에 애플리케이션에서 직접 식별자 값을 할당해야 한다.
  만약 식별자 값이 없으면 예외가 발생한다.
- SEQUENCE: 데이터베이스 시퀀스에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장한다.
- TABLE: 데이터베이스 시퀀스 생성용 테이블에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장한다.
- IDENTITY: 데이터베이스에 엔티티를 저장해서 식별자 값을 획득한 후 영속성 컨텍스트에 저장한다.
  즉, 테이블에 데이터를 저장해야 식별자 값을 획득할 수 있다.



### 권장하는 식별자 선택

1. DB 기본 키는 다음 3가지 조건을 만족해야 한다.
   - null값 허용하지 않는다.
   - 유일해야 한다.
   - 변해선 안된다.

2. 테이블의 기본 키를 선택하는 2가지 전략

   1. 자연 키
      - 비즈니스에 의미가 있는 키
      - ex: 주민등록번호, 이메일, 전화번호
   2. 대리 키(대체 키)
      - 비즈니스와 관련 없는 임의로 만들어진 키
      - ex : 오라클 시퀀스, auto_increment, 키생성 테이블 사용

   ### 자연 키보다는 대리 키를 권장

   - 자연 키인 전화번호를 기본 키로 선택한다면 그 번호가 유일할 수 있지만, 전화번호가 없을 수도 있고 전화번호가 변경될 수도 있다. 따라서 기본 키로 적당하지 않다.
   - 주민등록번호의 경우는 기본 키로 그럴듯 하게 보일 수 있지만 법적으로 주민등록번호를 저장할 수 없게 되다면 모든 기본 키로 사용없게 될 수 있다.
   - 그러므로 처음 설계할 때 부터 비즈니스와 관련 없는 대리 키를 사용했다면 요구사항이 변해도 수정할 부분이 많아지지는 않을 것이다.

